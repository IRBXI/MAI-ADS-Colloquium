1. Чем классы отличаются от структур в C++?

В классах все поля и методы по умолчанию private, а в структурах public. 

2. Что такое this?

this - это указатель на обьект, для которого вызывается этот не статический метод. 
В какой-то степени можно сказать, что он неявно передается первым параметром в не статические методы.
Это можно доказать использовав функцию std::bind из библиотеки functional, которая позволяет фиксировать параметры для функций.

```cpp
#include<functional>

struct S {
    int x;
    S(int x) : x(x) {}
    void print() { std::cout << x << '\n'; }
};

int main() {
    S s(5);
    auto f = std::bind(&S::print, &s);
    f(); // 5
}
```

Что важно, это при этом не работает:
```cpp
S::print(&s); // no matching function call
```

3. Что делает оператор ->?

Оператор -> в большинстве случаев просто соответствует такому выражению: 

```this-> == *(this)```

Это делает получение полей и методов от указателя на обьект проще:

```cpp
this->some_value; this->some_method()
// Вместо 
*(this).some_value; *(this).some_method()

```

cppreference говорит, что перегрузка оператора -> должна возвращать или сырой указатель или обьект (по ссылке или по значению), для которого оператор -> уже перегружен

"The overload of operator -> must either return a raw pointer, or return an object (by reference or by value) for which operator -> is in turn overloaded."

4. Что такое Shallow copy и Deep copy?

Shallow copy - это "поверхностное" копирование обьекта, то есть копируются просто значения, если мы встречаем указатель, то просто копируем его значение, не копирую то, что лежит под ним.

Deep copy - это "глубокое" копирование обьекта, то есть если мы встречаем указатель, то копируем то, что лежит под ним и делаем это рекурсивно, пока не останется только то, что можно скопировать и поверхностно. 

5. Что делает конструктор копирования?

Конструктор копирования конструирует новый обьект на основе другого обьекта такого же типа, то есть создает копию обьекта, от которого конструируется. 

Важно понимать, что это должно быть deep copy, а не shallow. 

6. Что напечатается?

```cpp
class A{
    A(){
        std::cout << "A\n";
    }
    ~A(){
        std::cout << "~A\n";
    }
}
class B{
    A a;
    B(){
        std::cout << "B\n";
    }
    ~B(){
        std::cout << "~B\n";
    }
}

main () {
    B b;
}
```

<details>
  <summary>Правильный ответ</summary>

    Ничего не распечатается) 

    Код не скомпилируется, так как main почему-то не имеет возращаемого значения, а должен иметь int.
    К тому же конструктуры и деструктуры A и B приватные, поэтому как создать обьект внутри B, так и создать обьект B в main не получится. 
    А еще после обьявления классов за последней фигурной скобкой должна идти ;

    Но если опустить все эти детали, которые вероятно являются опечатками и считать, что А и B это структуры или же их конструктуры и деструкторы являются публичными, то ответ такой: 

    A 
    B 
    ~B
    ~A 

    Сначала вызываются конструктуры внутренних обьектов, так как в моменту вызова конструктора все поля класса (структуры) уже должны быть проинициализированы 

    Деструкторы же всегда вызываются в обратном порядке конструкторам. 
</details>

7. Что нужно писать в деструкторах?

Не тривиальные действия, которые нужно сделать перед удалением обьекта (освобождения памяти, которое мы выделили внутри обьекта, закрытие соединения с базой данной и т.п.)

8. Чем конструктор копирования отличается от оператора =?

Конструктор копирования создает новый обьект на основе другого, оператор = же копирует обьект на место уже существующего (по этому при написании оператора = нужно не забывать освобождать память от старого обьекта)

9. Как заставить компилятор сгенерировать констурктор по умолчанию?

```cpp
class S {
    S() = default;
};
```

10. Как запретить компилятор генерировать констурктор по умолчанию?

```cpp
class S {
    S() = delete;
};
```

11. Что такое делегирующие конструкторы?*

```cpp
class S {
    S(int x, int y) {}

    S(int x): S(x, 1) {} 
};
```

Это способ вызывать другой конструктор перед тем начать выполнять тело того, из которого мы вызываем этот.

Их также нельзя совмещать с initializer lists. 

Что еще важно это не то же самое, что это: 

```cpp
class S {
    S(int x, int y) {}

    S(int x) {
        S(x, 1);
    } 
};
```

Тут мы создаем временный обьект вызывая его конструктор, но так как он не ассоциирован ни с какой переменной он сразу же удалится. 

