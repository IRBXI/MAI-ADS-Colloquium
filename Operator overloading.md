1. Что должен делать оператор копирования(оператор копирования это присваивание)
1.1 Удалить старые поля(например очистить память под указателями)
1.2 Скопировать все поля аналогично конструктору копирования
1.3 Обрабатывать самоприсваивание
1.4 Возвращать ссылку на текущий объект для цепочек присваивания(a=b=c)
Пример от дипсика:
```cpp
class String {
private:
    char* data;
    size_t size;

public:
    // Конструктор
    String(const char* str = "") {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    // Деструктор
    ~String() {
        delete[] data;
    }

    // Оператор копирования
    String& operator=(const String& other) {
        // 1. Проверка на самоприсваивание (a = a)
        if (this == &other) {
            return *this;
        }

        // 2. Освобождаем старые данные
        delete[] data;

        // 3. Копируем новые данные
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);

        // 4. Возвращаем *this для цепочки присваиваний
        return *this;
    }
};
```
2. Что будет
```cpp
class String{
public:
    char* buffer;
    size_t sz;

    String() {
        buffer = new char[128];
    }

    ~String() {
        delete[] buffer;
    }

    String& operator=(const String& other){
        delete buffer; //WTF
        this->buffere = other.buffer;// minor typing mistake
        this->sz = other.sz;
    }
}

int main{
    String s;
    s = s;
}
```
Будет ошибка компиляции, потому что Сысоев допустил minor typing mistake. Да и еще освобождает массив через delete без \[\].
Ну тут он скорее хочет показать про самоприсваивание. Если бы не опечатки, то было бы UB из-за двойного удаления. 1 от оператора копирования, другое от деструктора.
3. Как явно вызвать деструктор? Какие подводные камни у этого есть?
Можно явно вызвать деструктор, как метод класса. Выглядит это так:
```cpp
T obj;
obj.~T();
```
Подводные камни: 
3.1 после вызова деструктора компилятор имеет право считать, что объект больше не будет использоваться, поэтому обращение к его полям и методам UB.
3.2 Может произойти второй вызов деструктора после выхода из блока. Два вызова деструктора UB.
```cpp
#include <iostream>

class MyClass {
public:
    ~MyClass() { std::cout << "Destructor called\n"; }
};

int main() {
    MyClass obj;
    obj.~MyClass();  // Явный вызов деструктора
    return 0;
}  // Деструктор вызовется снова → UB!
```
4. Что такое **copy and swap**
**copy and swap** - идиома для оператора копирования. Сильно сокращает код. Мы копируем другой объект во временный, меняем наш на временный с помощью `swap`, деструктор временного удаляет за нас старый объект.
```cpp
String& operator=(const String& other) {
    String temp(other);  // Конструктор копирования
    swap(temp);          // Обмен данными (нужно реализовать swap)
    return *this;
} //удаление старого объекта через деструктор
```
5. Что такое правило трёх(и пяти)?
Правило трех: если явно определен для класса один из 3 методов:
Деструктор, конструктор копирования, оператор копирования, то надо определить все 3.
Правило пяти: если явно определен для класса один из 5 методов:
Деструктор, конструктор копирования, оператор копирования, конструктор перемещения, оператор перемещения. То надо определить все 5.
6. Зачем нужны списки инициализации
Пример списка инициализации:
```cpp
class Example {
    const int value;
    int& ref;
public:
    Example(int x, int& yref) 
        : value(x),  // Инициализация константы
          ref(yref) // Инициализация ссылки
    {}
};
```
6.1 Инициализация ссылок и константных полей.
6.2 Инициализация объектов без конструктора по умолчанию
6.3 Список инициализации позволяет явно задать значение по умолчанию, чтобы избежать лишней инициализации объекта.
7. Что проинициализируется первым
```cpp
class String{
public:
    char* buffer;
    size_t sz;
    String(): sz(128), buffer(new char[128]) {}
```
buffer, так как порядок инициализации совпадает с порядком декларации полей в классе.
8. Что такое `Return Value Optimization(RVO)`?
RVO - оптимизация, указанная в стандарте с C++17. Ее суть заключается в оптимизации возвращение объектов из функции. Если четко определено какой объект вернется, то память под него создастся на стороне, которая вызывает функцию.
```cpp
MyClass create() { //NRVO - named return value optimization(не гарантируется стандартом, но есть почти везде)
    MyClass obj;
    return obj;
}
```
```cpp
MyClass func(){
	return MyClass(); //RVO
}
```
9. Почему `++Object` лучше `Object++`?
Object++ обязан возвращать объект до операции инкремента, а значит копировать старый объект. А вот ++Object возвращает ссылку на тот же объект, над которым мы сделали инкремент.
10. Как перегружать операторы каста? Чтобы делать так:
```cpp
int main(){
    String s = "124";
    int a = (int)s;
}
```
Вот так:
```cpp
#include <iostream>
class Length{
    int length;
    public:
        Length(int a): length(a){}
        explicit operator int(){
            return length;
        }
};
int main(){
    Length a(10);
    std::cout << static_cast<int>(a) + 5 << '\n';
}
```
Рекомендуется ставить ключевое слово `explicit` перед операторами каста, чтобы не было неявных кастов.


