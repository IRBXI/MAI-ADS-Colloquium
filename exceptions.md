1. Что происходит во время выполнения кода:

```cpp
throw 1;
```

Начнется обратная раскрутка стека, для сложных обьектов сначала будет вызван деструктор, а потом будет освобождена, выделенная для них на стеке, память.

В случае если нигде по дороге к main никто не поймает exception и в мейне его также никто не поймает будет вызван std::terminate и остановлена работа программы.

2. Чем отличается exception от RE?

exception можно поймать, а RE неизбежно приводит к остановке программы 

3. Как поймать любое исключение?

```cpp
try {

} catch(...) {

}
```

4. Какие два оператора в C++ имеют исключения?

Оператор new кидает std::bad_alloc в случае если не удалось выделить память (в большинcтве случаев так как на хипе кончилось память)

Тем не менее и его можно сделать noexcept вызывав его с тегом std::nothrow -> 
```int* p = new(std::nothrow) int[10000000000ull]; // nullptr```

В этом случае new будет возвращать nullptr, если не получилось аллоцировать память, аналогично malloc 

Оператор dynamic_cast кидает std::bad_cast, если преобразование к ссылке невозможно. В случае если преобразование невозможно, но кастим к указателю, получим nullptr

На самом деле есть еще один оператор, который может кинуть исключение. 

Это typeid, он кинет исключение std::bad_typeid в случае если переданный ему разименованный указатель на полиморфный тип окажется нулевым. 

5. Создают ли копии объектов throw и catch?

Да, создаются. 

В catch этого можно избежать, если принимать обьект, который ловим по ссылке.

6. Производится ли касты типов в catch? 

В большинстве случаев нет. Единственным исключением является каст указателя на ребенка к указателю на родителя.

7. Что такое RAII?

Это идиома, которая расшифровывается как Resource Acquisition Is Initialization. (Получение ресурса есть инициализация)

По сути это означает, что обьект, который завладевает ресурсом и должен быть ответственным за его особождение. 
В языке C++ это используется повсеместно, так как конструктуры и деструктуры обьектов по сути и являются прямым применением данной идиомы.

В идеале мы не должны сами выделять и освобождать память, так как мы можем легко про это забыть. То есть в идеале не нужно использовать сырые указатели вместе с new и delete. Поэтому были придуманы умные указатели, которые сами освобождать память, после выхода из области видимости. std::shared_ptr же освобождает память тогда, когда на обьект больше не остается ссылок. 

8. Что такое noexcept?

В случае использования noexcept в обьявлении функции это говорит компилятору и тому, кто собирается данную функцию вызывать, что данная функция не может кидать исключения. Это позволяет немного ускорить выполнение таких функций, так как компилятору не надо быть готовым к тому, чтобы обрабатывать исключения. 

Тем не менее, она может его все равно кинуть... В данном случае будет сразу вызван std::terminate и выполнение программы будет завершено. 

Также стоит отметить, что все деструкторы с С++11 по умолчанию неявно помечены noexcept и чтобы пометить, что деструктор может кидать исключение нужно написать noexcept(false)

Также в С++11 был добавлен оператор noexcept, который позволяет во время компиляции проверить является ли функциия noexcept. Он возращает true, если функция действительно noexcept и false в обратном. 

9. Что такое weak/strong exception safety?

weak exception safety гарантирует, что в случае эксепшена все обьекты, с которыми как-либо связан это исключение, останутся в валидном состоянии.

strong exception safety гарантирует, что в случае эксепшена все обьекты, с которыми как-либо связан это исключение, останутся не только в валидном состоянии, но также и останутся ровно в том же состоянии, в котором они были до применения операции, которая вызвала исключение.
